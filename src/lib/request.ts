/*
 * This code was auto generated by AfterShip SDK Generator.
 * Do not edit the class manually.
 */
import axios, { AxiosRequestConfig } from "axios";
import { AuthType, Authentication } from "./authentication";
import { AftershipError } from "../error";
import { AfterShipErrorCodes } from "../error/code";
import { AfterShipMetaCodeMap } from "../error/meta_code";
import { Proxy } from "../utils/parse_proxy";

export const DEFAULT_DOMAIN = "https://api.aftership.com";
export const DEFAULT_TIMEOUT = 10000;
export const DEFAULT_MAX_RETRY = 3;
export const MAX_MAX_RETRY = 10;
export const MIN_MAX_RETRY = 0;
export const DEFAULT_USER_AGENT = "tracking-sdk-nodejs/11.0.0 (https://www.aftership.com) axios/1.7.2";

type ResponseData = {
    meta: {
        code: number;
        message: number;
        type: string;
    },
    data: any;
}

export interface RequestConfig {
    url: string;
    method: string;
    body?: any;
    query?: any;
    headers?: { [key: string]: any };
    request_legacy_tag: string;
    response_legacy_tag: string;
    is_paging: boolean;
}

export interface RequestOptions {
    auth_type: string;
    api_key?: string;
    api_secret?: string;
    domain: string;
    max_retry: number;
    timeout: number;
    user_agent?: string;
    proxy?: Proxy;
}

export class Request {
    private readonly options: RequestOptions;

    private readonly DELAY_BASE = 3000;

    constructor(options: RequestOptions) {
        this.options = options;
    }

    private getHeaders(config: RequestConfig): { [key: string]: any } {
        const content_type = "application/json";
        const headers: { [key: string]: any } = {
            "as-api-key": this.options.api_key,
            "Content-Type": content_type,
            "User-Agent": this.options.user_agent || DEFAULT_USER_AGENT,
            "aftership-client": DEFAULT_USER_AGENT,
            ...config.headers,
        };

        if (
            this.options.auth_type === AuthType.AES ||
            this.options.auth_type === AuthType.RSA
        ) {
            const header_keys = this.options.auth_type === AuthType.AES ? "as-signature-hmac-sha256" : "as-signature-rsa-sha256"
            const date_now = new Date().toUTCString();
            headers[header_keys] = Authentication.sign({
                method: config.method,
                url: config.url,
                body: JSON.stringify(config.body),
                content_type,
                query: config.query,
                auth_type: this.options.auth_type,
                date: date_now,
                private_key: this.options.api_secret,
                headers,
            });
            headers["date"] = date_now;
        }
        return headers;
    }

    private shouldRetry(error: any): boolean {
        if (error.code === "ECONNABORTED") {
            return true;
        }
        if (error.response && error.response.status >= 500) {
            return true;
        }
        return false;
    }

    private delayWithJitter(retry_attempt: number): Promise<unknown> {
        const delay = (this.DELAY_BASE * 2) ^ (retry_attempt - 1);

        // jitter between -halfOfTheDelay seconds and halfOfTheDelay seconds
        const jitter = delay * (Math.random() - 0.5);

        // to ensure the delay would not be less than 1 second even if the delayBase is smaller than 2
        const totalDelay = Math.max(1, delay + jitter);

        return new Promise((resolve) => {
            setTimeout(resolve, totalDelay);
        });
    }

    private async withRetry<T>(requestConfig: AxiosRequestConfig, retry: number = 0): Promise<T> {
        try {
            const response = await axios<T>(requestConfig);
            return response.data;
        } catch (error: any) {
            if (this.shouldRetry(error) && retry < this.options.max_retry) {
                await this.delayWithJitter(retry);
                retry++;
                return this.withRetry(requestConfig, retry);
            }
            throw error;
        }
    }

    public async makeRequest<T>(config: RequestConfig): Promise<T> {
        config.body = this.handleRequestData(config.request_legacy_tag, config.body)
        const headers = this.getHeaders(config);
        try {
            const response = await this.withRetry<ResponseData>(
                {
                    url: config.url,
                    method: config.method,
                    headers,
                    params: config.query,
                    validateStatus: (status) => status >= 200 && status < 400,
                    baseURL: this.options.domain,
                    data: config.body,
                    timeout: this.options.timeout,
                    proxy: this.options.proxy,
                }
            );
            return response.data;
        } catch (error) {
            throw this.handleError(error);
        }
    }

    private handleError(e: any): Error {
        if (e.code === "ECONNABORTED") {
            return new AftershipError(
                "Request timed out.",
                AfterShipErrorCodes.TIMED_OUT
            );
        } else if (e instanceof AftershipError) {
            return e;
        } else if (e.response && e.response.status >= 500) {
            return new AftershipError(
                e.response?.data?.meta?.message || e.message,
                AfterShipErrorCodes.INTERNAL_ERROR,
                e.response.status,
                e.response.status,
                JSON.stringify(e.response?.data)
            );
        } else {
            return new AftershipError(
                e.response?.data?.meta?.message,
                AfterShipMetaCodeMap[e.response?.data?.meta?.code?.toString()],
                e.response?.data?.meta?.code,
                e.response?.status,
                JSON.stringify(e.response?.data)
            );
        }
    }

    private handleRequestData(request_legacy_tag: string, data: any): any {
        if (!request_legacy_tag) {
            return data;
        }
        return {
            [request_legacy_tag]: data
        }
    }
}
